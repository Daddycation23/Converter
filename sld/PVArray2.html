<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PV Single Line Diagram</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f0f0f0;
        }
        .container {
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            margin-bottom: 20px;
            overflow: auto;
        }
        canvas {
            border: 1px solid #ccc;
        }
        h2 {
            margin-top: 0;
        }
    </style>
</head>
<body>
    <h1>PV Single Line Diagram</h1>
    
    <div id="diagrams"></div>

    
<script>
  const pvData = {
    "PVArray2": {"inverters":[{"isolators":[{"pvstrings":[{"model":"Panasonic 330W HiT","length":12},{"model":"Panasonic 330W HiT","length":12}]},{"pvstrings":[{"model":"Panasonic 330W HiT","length":10},{"model":"Panasonic 330W HiT","length":10},{"model":"Panasonic 330W HiT","length":10}]},{"pvstrings":[{"model":"Panasonic 330W HiT","length":10},{"model":"Panasonic 330W HiT","length":10},{"model":"Panasonic 330W HiT","length":10}]},{"pvstrings":[{"model":"Panasonic 330W HiT","length":10},{"model":"Panasonic 330W HiT","length":10},{"model":"Panasonic 330W HiT","length":10}]}]},{"isolators":[{"pvstrings":[{"model":"Panasonic 330W HiT","length":12},{"model":"Panasonic 330W HiT","length":12},{"model":"Panasonic 330W HiT","length":12}]},{"pvstrings":[{"model":"Panasonic 330W HiT","length":12},{"model":"Panasonic 330W HiT","length":12},{"model":"Panasonic 330W HiT","length":12}]},{"pvstrings":[{"model":"Panasonic 330W HiT","length":12},{"model":"Panasonic 330W HiT","length":12},{"model":"Panasonic 330W HiT","length":12},{"model":"Panasonic 330W HiT","length":12},{"model":"Panasonic 330W HiT","length":12}]},{"pvstrings":[{"model":"Panasonic 330W HiT","length":12},{"model":"Panasonic 330W HiT","length":12},{"model":"Panasonic 330W HiT","length":12},{"model":"Panasonic 330W HiT","length":12},{"model":"Panasonic 330W HiT","length":12}]}]}]}
  };
</script>


    <script>
        // Constants for drawing
        const CONFIG = {
            panel: { width: 60, height: 40, spacing: 20, borderRadius: 5 },
            isolator: { width: 80, height: 50, margin: 40 }, 
            inverter: { width: 150, height: 150, margin: 50 },
            stringSpacing: 60, // Vertical space between strings
            busSpacing: 0, // Unused now
            wireSpacing: 4, // Spacing between parallel wires
            colors: {
                positive: 'red',
                negative: 'black',
                panel: '#fff',
                stroke: 'black',
                text: '#000'
            }
        };

        function drawRoundedRect(ctx, x, y, width, height, radius) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            ctx.fill(); // Fill first
            ctx.stroke();
        }

        function renderDiagram(name, data) {
            // Loop through all Inverters in the data set
            data.inverters.forEach((inverter, invIndex) => {
                const container = document.createElement('div');
                container.className = 'container';
                container.innerHTML = `<h2>${name} - Inverter ${invIndex + 1}</h2>`;
                
                const canvas = document.createElement('canvas');
                container.appendChild(canvas);
                document.getElementById('diagrams').appendChild(container);
                
                const ctx = canvas.getContext('2d');

                // 1. Calculate Stats and Dimensions for THIS Inverter
                let totalStrings = 0;
                let maxStringLength = 0;
                const isolatorsCount = inverter.isolators.length;
                
                inverter.isolators.forEach(iso => {
                    totalStrings += iso.pvstrings.length;
                    iso.pvstrings.forEach(str => {
                        if (str.length > maxStringLength) maxStringLength = str.length;
                    });
                });

                // Layout Config
                const startX = 50;
                const topMargin = 50;
                const bottomMargin = 50;
                
                const stringHeight = CONFIG.panel.height + CONFIG.stringSpacing;
                const stringsTotalHeight = (totalStrings * stringHeight);
                
                // Calculate Isolator Row Width
                const isolatorRowWidth = (isolatorsCount * CONFIG.isolator.width) + ((isolatorsCount - 1) * 60); // 60px gap
                
                // Dynamic Inverter Width Calculation
                const minInputWidth = 35; // Safe width per input
                const dynamicInverterWidth = Math.max(CONFIG.inverter.width, isolatorsCount * minInputWidth);
                
                // Left Section Width (Inverter/Isolators)
                const leftSectionWidth = Math.max(dynamicInverterWidth, isolatorRowWidth);
                
                // Strings above Isolators
                const requiredStringSectionHeight = stringsTotalHeight + 50; // + padding
                
                // Staggered Drop Calculation
                const maxDrop = 40 + (Math.ceil(isolatorsCount/2) * 20);
                
                const isoY = topMargin + requiredStringSectionHeight;
                const invY = isoY + CONFIG.isolator.height + maxDrop + 40; // ample space
                const totalHeight = invY + CONFIG.inverter.height + bottomMargin;

                // Calculate Width
                const stringSectionWidth = maxStringLength * (CONFIG.panel.width + CONFIG.panel.spacing);
                const totalWidth = startX + leftSectionWidth + 100 + stringSectionWidth + 100;
                
                canvas.width = totalWidth;
                canvas.height = totalHeight;
                
                ctx.font = "12px Arial";

                // 2. Determine Positions
                
                // Inverter Position (Bottom Left Area)
                const invX = startX + (leftSectionWidth - dynamicInverterWidth) / 2;
                
                // Start X for the group
                const isoGroupStartX = startX + (leftSectionWidth - isolatorRowWidth) / 2;
                
                // Draw Inverter
                ctx.strokeStyle = CONFIG.colors.stroke;
                ctx.fillStyle = '#fff';
                drawRoundedRect(ctx, invX, invY, dynamicInverterWidth, CONFIG.inverter.height, 10);
                ctx.fillStyle = CONFIG.colors.text;
                ctx.textAlign = "center";
                ctx.fillText("Inverter", invX + (dynamicInverterWidth/2), invY + (CONFIG.inverter.height/2));
                ctx.textAlign = "left";
                
                let globalStringIndex = 0;
                let currentStringY = topMargin;

                // Center Index for Stagger Logic
                const centerIdx = (isolatorsCount - 1) / 2;

                // Iterate Isolators
                inverter.isolators.forEach((iso, idx) => {
                    const isoX = isoGroupStartX + (idx * (CONFIG.isolator.width + 60));
                    const isoCenterX = isoX + (CONFIG.isolator.width / 2);
                    
                    // Draw Isolator
                    ctx.strokeStyle = CONFIG.colors.stroke;
                    ctx.fillStyle = '#fff';
                    ctx.fillRect(isoX, isoY, CONFIG.isolator.width, CONFIG.isolator.height);
                    ctx.strokeRect(isoX, isoY, CONFIG.isolator.width, CONFIG.isolator.height);
                    ctx.fillStyle = CONFIG.colors.text;
                    ctx.textAlign = "center";
                    ctx.fillText(`Isolator ${idx + 1}`, isoX + (CONFIG.isolator.width/2), isoY + (CONFIG.isolator.height/2));
                    
                    // --- Isolator to Inverter Connection (Dynamic Depth) ---
                    const isoBottomY = isoY + CONFIG.isolator.height;
                    
                    const isoOutPos = isoCenterX - 10; 
                    const isoOutNeg = isoCenterX + 10;
                    
                    // Inverter Input Points (Distributed across Dynamic Width)
                    const invInputSectionWidth = dynamicInverterWidth / isolatorsCount;
                    const invInputCenterX = invX + (invInputSectionWidth * idx) + (invInputSectionWidth/2);
                    const invInPos = invInputCenterX - 10;
                    const invInNeg = invInputCenterX + 10;
                    
                    // Staggered Midpoint Base
                    const distFromCenter = Math.abs(idx - centerIdx);
                    const dropDepth = 40 + (distFromCenter * 40); // 40px step
                    const midY = isoBottomY + dropDepth;
                    
                    // Determine Routing Direction
                    const movingRight = invInputCenterX > isoCenterX;
                    
                    let posMidY, negMidY;
                    if (movingRight) {
                        // Moving Right -> Pos is 'Outer', needs deeper path to cross under Neg's vertical
                        posMidY = midY + 15;
                        negMidY = midY;
                    } else {
                        // Moving Left -> Neg is 'Outer', needs deeper path
                        posMidY = midY;
                        negMidY = midY + 15;
                    }
                    
                    // Handle near-vertical case
                    if (Math.abs(invInputCenterX - isoCenterX) < 10) {
                        posMidY = midY;
                        negMidY = midY + 10;
                    }

                    // Positive (Red)
                    ctx.strokeStyle = CONFIG.colors.positive;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(isoOutPos, isoBottomY);
                    ctx.lineTo(isoOutPos, posMidY); // Down
                    ctx.lineTo(invInPos, posMidY); // Horizontal
                    ctx.lineTo(invInPos, invY); // Down to Inverter
                    ctx.stroke();
                    
                    // Negative (Black)
                    ctx.strokeStyle = CONFIG.colors.negative;
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(isoOutNeg, isoBottomY);
                    ctx.lineTo(isoOutNeg, negMidY); // Down
                    ctx.lineTo(invInNeg, negMidY); // Horizontal
                    ctx.lineTo(invInNeg, invY); // Down to Inverter
                    ctx.stroke();


                    // Process Strings (Isolator to Panels)
                    iso.pvstrings.forEach((string, strIndex) => {
                        const stringStartX = startX + leftSectionWidth + 80; // Direct offset
                        const stringY = currentStringY;
                        const panelY = stringY;
                        const panelCenterY = panelY + (CONFIG.panel.height / 2);
                        
                        // Draw Panels
                        for (let i = 0; i < string.length; i++) {
                            const px = stringStartX + (i * (CONFIG.panel.width + CONFIG.panel.spacing));
                            ctx.strokeStyle = CONFIG.colors.stroke;
                            ctx.fillStyle = CONFIG.colors.panel;
                            ctx.lineWidth = 2;
                            drawRoundedRect(ctx, px, panelY, CONFIG.panel.width, CONFIG.panel.height, CONFIG.panel.borderRadius);
                        }
                        
                        // Series Connections
                        const lastPanelX = stringStartX + ((string.length - 1) * (CONFIG.panel.width + CONFIG.panel.spacing));
                        ctx.strokeStyle = CONFIG.colors.positive;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        for (let i = 0; i < string.length - 1; i++) {
                            const p1x = stringStartX + (i * (CONFIG.panel.width + CONFIG.panel.spacing)) + CONFIG.panel.width;
                            const p2x = stringStartX + ((i + 1) * (CONFIG.panel.width + CONFIG.panel.spacing));
                            ctx.moveTo(p1x, panelCenterY);
                            ctx.lineTo(p2x, panelCenterY);
                        }
                        ctx.stroke();

                        // --- WIRING: Isolator to String (Direct L-Shape) ---
                        const isoWidth = CONFIG.isolator.width;
                        const totalWires = iso.pvstrings.length * 2;
                        const wireStep = isoWidth / (totalWires + 1);
                        
                        const wireIndex = strIndex * 2;
                        const startX_Pos = isoX + (wireStep * (wireIndex + 1));
                        const startX_Neg = isoX + (wireStep * (wireIndex + 2));
                        const isoTopY = isoY;

                        // Positive Wire (Red)
                        ctx.strokeStyle = CONFIG.colors.positive;
                        ctx.lineWidth = 2; 
                        ctx.beginPath();
                        ctx.moveTo(startX_Pos, isoTopY);
                        ctx.lineTo(startX_Pos, panelCenterY - CONFIG.wireSpacing); // Vertical Rise
                        ctx.lineTo(stringStartX, panelCenterY - CONFIG.wireSpacing); // Horizontal Run
                        ctx.stroke();
                        
                        // Negative Wire (Black)
                        ctx.strokeStyle = CONFIG.colors.negative;
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(startX_Neg, isoTopY);
                        ctx.lineTo(startX_Neg, panelCenterY + CONFIG.wireSpacing); // Vertical Rise
                        ctx.lineTo(stringStartX - 10, panelCenterY + CONFIG.wireSpacing); // Horizontal Run to meet Return Path
                        ctx.stroke();
                        
                        // Return Path Logic
                        ctx.strokeStyle = CONFIG.colors.negative;
                        ctx.lineWidth = 1;
                        ctx.beginPath();
                        const lastPanelRight = stringStartX + ((string.length - 1) * (CONFIG.panel.width + CONFIG.panel.spacing)) + CONFIG.panel.width;
                        ctx.moveTo(lastPanelRight, panelCenterY);
                        ctx.lineTo(lastPanelRight + 10, panelCenterY);
                        const returnY = panelY + CONFIG.panel.height + 5;
                        ctx.lineTo(lastPanelRight + 10, returnY);
                        ctx.lineTo(stringStartX - 10, returnY);
                        ctx.lineTo(stringStartX - 10, panelCenterY + CONFIG.wireSpacing);
                        ctx.stroke();
                        
                        currentStringY += stringHeight;
                        globalStringIndex++;
                    });
                    
                    currentStringY += 20; // Gap between isolator groups
                });
            });
        }

        // Render all available data
        for (const [name, data] of Object.entries(pvData)) {
            renderDiagram(name, data);
        }
    </script>
</body>
</html>