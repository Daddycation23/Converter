<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Canvas Sample</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
</head>
<body>
  <!-- Canvas element -->
  <canvas id="mainCanvas" style="display:block; width:100%; height:400px;"></canvas>

  <script>
    // Basic setup: get canvas and 2D context
    const canvas = document.getElementById('mainCanvas');
    const ctx = canvas.getContext('2d', { alpha: false });

    // Resize canvas to fill CSS size, with devicePixelRatio handling for sharpness
    function resizeCanvas() {
      const dpr = window.devicePixelRatio || 1;
      // match CSS layout size
      const rect = canvas.getBoundingClientRect();
      canvas.width = Math.round(rect.width * dpr);
      canvas.height = Math.round(rect.height * dpr);
      // scale drawing operations to device pixels
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    // initial resize
    resizeCanvas();
    // keep canvas sized on window resize
    window.addEventListener('resize', resizeCanvas);

    // Demo state: a bouncing ball
    const ball = {
      x: 80,
      y: 80,
      vx: 160, // px/sec
      vy: 120,
      r: 20
    };

    // Track mouse for interaction
    const mouse = { x: null, y: null };

    canvas.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      // coordinates in CSS pixels (because ctx is scaled by DPR already)
      mouse.x = e.clientX - rect.left;
      mouse.y = e.clientY - rect.top;
    });
    canvas.addEventListener('mouseleave', () => {
      mouse.x = null; mouse.y = null;
    });

    // Draw helper: grid + instructions
    function drawBackground() {
      // clear canvas (in CSS pixels)
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // draw light grid
      const step = 50;
      ctx.lineWidth = 1;
      ctx.strokeStyle = '#e6e6e6';
      for (let x = 0; x < canvas.width; x += step) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
      }
      for (let y = 0; y < canvas.height; y += step) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
      }

      // title text
      ctx.fillStyle = '#111';
      ctx.font = '16px system-ui, -apple-system, Roboto, "Segoe UI", Arial';
      ctx.fillText('Canvas demo: bouncing ball + mouse follower', 12, 22);
    }

    // Draw the ball
    function drawBall() {
      ctx.beginPath();
      ctx.fillStyle = '#0077cc';
      ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI * 2);
      ctx.fill();

      // subtle highlight
      ctx.beginPath();
      ctx.fillStyle = 'rgba(255,255,255,0.25)';
      ctx.arc(ball.x - ball.r/3, ball.y - ball.r/3, ball.r/4, 0, Math.PI * 2);
      ctx.fill();
    }

    // Draw mouse follower (small circle near mouse)
    function drawMouseFollower() {
      if (mouse.x === null) return;
      ctx.beginPath();
      ctx.fillStyle = 'rgba(220,60,60,0.9)';
      ctx.arc(mouse.x, mouse.y, 8, 0, Math.PI * 2);
      ctx.fill();

      ctx.font = '12px system-ui, -apple-system, Roboto, "Segoe UI", Arial';
      ctx.fillStyle = '#333';
      ctx.fillText(`(${Math.round(mouse.x)}, ${Math.round(mouse.y)})`, mouse.x + 12, mouse.y - 10);
    }

    // Physics step and animation
    let lastTime = performance.now();
    function animate(now) {
      const dt = (now - lastTime) / 1000; // seconds
      lastTime = now;

      // update ball position
      ball.x += ball.vx * dt;
      ball.y += ball.vy * dt;

      const width = canvas.clientWidth;
      const height = canvas.clientHeight;

      // collision with edges (simple bounce)
      if (ball.x - ball.r < 0) {
        ball.x = ball.r;
        ball.vx *= -1;
      } else if (ball.x + ball.r > width) {
        ball.x = width - ball.r;
        ball.vx *= -1;
      }
      if (ball.y - ball.r < 0) {
        ball.y = ball.r;
        ball.vy *= -1;
      } else if (ball.y + ball.r > height) {
        ball.y = height - ball.r;
        ball.vy *= -1;
      }

      // slowly steer ball toward mouse if present
      if (mouse.x !== null) {
        const ax = (mouse.x - ball.x) * 0.5; // attraction strength
        const ay = (mouse.y - ball.y) * 0.5;
        ball.vx += ax * dt;
        ball.vy += ay * dt;
      }

      // draw
      drawBackground();
      drawBall();
      drawMouseFollower();

      requestAnimationFrame(animate);
    }

    // Kick off animation loop
    requestAnimationFrame(animate);
  </script>
</body>
</html>
